\nsection{Data structures}

% \subsection{Disjoint set}
% \addfile{../Codes/DataStructures/DSU.cpp}

\subsection{Disjoint set with rollback}
\addfile{../Codes/DataStructures/DSU Rollback.cpp}

\horizontalLine

\subsection{Monotone queue}
\addfile{../Codes/DataStructures/Monotone Queue.cpp}

\subsection{Mo's algorithm}
\addfile{../Codes/DataStructures/Mos.cpp}
To make it faster, change the order to $hilbert(l, r)$ \\
\addfile{../Codes/DataStructures/Hilbert Order.cpp}

% \subsection*{Mo's algorithm with updates in \complexity{n^{\frac{5}{3}}} }
  
% \setlist{nolistsep}
% \begin{itemize}[noitemsep]
%   \item Choose a $block$ of size $n^{\frac{2}{3}}$
%   \item Do a normal Mo's algorithm, in the $Query$ definition add an extra variable for the $updatesSoFar$ 
%   \item Sort the queries by the order $(l /block$, $r / block$, $updatesSoFar)$
%   \item If the update lies inside the current query, update the data structure properly \\
%   \begin{code}
%    struct Update {
%      int pos, prv, nxt;
%    };
  
%    void undo(Update &u) {
%      if (l <= u.pos && u.pos <= r) {
%        rem(u.pos);
%        a[u.pos] = u.prv;
%        add(u.pos);
%      } else {
%        a[u.pos] = u.prv;
%      }
%    }
%   \end{code}
    
%   \item Solve the problem :D \\
%   \begin{code}
%    l = queries[0].l, r = l - 1, upd = sz(updates) - 1;
%    for (Query &q : queries) {
%      while (upd < q.upd)
%        dodo(updates[++upd]);
%      while (upd > q.upd)
%        undo(updates[upd--]);
%      // write down the normal Mo's algorithm
%    }
%   \end{code}
% \end{itemize}
% \vspace{-15pt}

\subsection{Static to dynamic}
\addfile{../Codes/DataStructures/Static to dynamic.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nsection{Intervals}

\subsection{Disjoint intervals}
\addfile{../Codes/DataStructures/Disjoint Intervals.cpp}

\subsection{Interval tree}
\addfile{../Codes/DataStructures/Interval Tree.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nsection{Range queries}

\subsection{Sparse table}
\addfile{../Codes/DataStructures/Sparse Table.cpp}

\subsection{Squirtle decomposition}
\vspace{-18pt}
\begin{minipage}{70mm}
  The perfect block size is $squirtle$ of N
\end{minipage}
\begin{minipage}{15mm}
  \includegraphics[width=\linewidth]{squirtle.png} 
\end{minipage}
\addfile[]{../Codes/DataStructures/Sqrt Decomposition.cpp}
\vspace{-18pt}

% \subsection{In-Out trick}
% \addfile{../Codes/DataStructures/InOutTrick.cpp}

\subsection{Parallel binary search}
\addfile{../Codes/DataStructures/Parallel Binary Search.cpp}

\subsection{D-dimensional Fenwick tree}
\addfile[1-28]{../Codes/DataStructures/Fenwick ND.cpp}

\subsection{Fenwick tree 2D}
\addfile{../Codes/DataStructures/Fenwick2D Offline.cpp}

% \subsection{Segment tree}
% \addfile{../Codes/DataStructures/Segtree.cpp}

% \subsection{Lazy segment tree}
% \addfile{../Codes/DataStructures/LazySegtree.cpp}

\subsection{Dynamic segment tree}
\addfile{../Codes/DataStructures/Dynamic Segtree.cpp}

\subsection{Persistent segment tree}
\addfile{../Codes/DataStructures/Persistent Segtree.cpp}

\subsection{Wavelet tree}
\addfile{../Codes/DataStructures/Wavelet.cpp}

\subsection{Li Chao tree}
\addfile{../Codes/DataStructures/Li Chao.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nsection{Trees}

\subsection{Ordered tree}
\addfile{../Codes/DataStructures/Ordered tree.cpp}

\subsection{Unordered tree}
\addfile[4]{../Codes/DataStructures/Unordered tree.cpp}

\subsection{Explicit treap}
\addfile[1-93]{../Codes/DataStructures/Treap.cpp}

\subsection{Implicit treap}
\addfile[95]{../Codes/DataStructures/Treap.cpp}

\subsection{Splay tree}
\addfile{../Codes/DataStructures/Splay.cpp}