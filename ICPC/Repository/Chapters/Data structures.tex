\nsection{Data structures}

\subsection{DSU rollback }
\addcode{../Codes/Data structures/DSU rollback.cpp}

\subsection{Monotone queue \complexity{n}}

\addcode{../Codes/Data structures/Monotone queue.cpp}

\subsection{Stack queue \complexity{n}}

\addcode{../Codes/Data structures/Stack queue.cpp}

\subsection{In-Out trick }
\addcode{../Codes/Data structures/In-Out trick.cpp}

\subsection{Parallel binary search \complexity{(n + q) \cdot log n}}

Hay $q$ queries, $n$ updates, se pide encontrar cuándo se cumple cierta condición con un prefijo de updates.\\
\addcode{../Codes/Data structures/Parallel binary search.cpp}

\subsection{Mos \complexity{(n + q) \cdot \sqrt{n}}}

Mo's in a tree, extended euler tour tin[u] = ++timer, tout[u] = ++timer 

\begin{itemize}
\item u = lca(u, v), query(tin[u], tin[v])
\item u $\neq$ lca(u, v), query(tout[u], tin[v]) + query(tin[lca], tin[lca]) 
\end{itemize}


\addcode{../Codes/Data structures/Mos.cpp}

\subsection{Hilbert order }
\input{../Codes/Data structures/Hilbert order.tex}
\addcode{../Codes/Data structures/Hilbert order.cpp}

\subsection{Sqrt decomposition }
\addcode{../Codes/Data structures/Sqrt decomposition.cpp}

\subsection{Sparse table }
\addcode{../Codes/Data structures/Sparse table.cpp}

\subsection{Fenwick }
\addcode{../Codes/Data structures/Fenwick.cpp}

\subsection{Fenwick 2D offline }
\addcode{../Codes/Data structures/Fenwick 2D offline.cpp}

\subsection{Lazy segtree }
\addcode{../Codes/Data structures/Lazy segtree.cpp}

\subsection{Dynamic segtree }
\addcode{../Codes/Data structures/Dynamic segtree.cpp}

\subsection{Persistent segtree }
\addcode{../Codes/Data structures/Persistent segtree.cpp}

\subsection{Li Chao }
\addcode{../Codes/Data structures/Li Chao.cpp}

\subsection{Wavelet }
\addcode{../Codes/Data structures/Wavelet.cpp}

\subsection{Ordered tree }
\input{../Codes/Data structures/Ordered tree.tex}
\addcode{../Codes/Data structures/Ordered tree.cpp}

\subsection{Treap }
\addcode{../Codes/Data structures/Treap.cpp}
